/*
Concepts:

Routines (.fork) is a shortcut for a Routine
Arrays
syntactic shortcuts
Tempo Clock
midi to freq conversion
note duration
*/


/*
Homework:

1. design a synth def which is able to play individual notes
2. create three melodic patterns using the {}.fork routine
3. use arrays access the pitch and note durations

4. create a synth def which triggers sound files
5. send these through effects


*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/


SynthDef(\mySynth,{

	arg freq;
	var signal, env;

	env = EnvGen.ar(Env.perc,doneAction:2);
	signal = SinOsc.ar(freq) * env;
	Out.ar(0,[signal,signal]);

}).add;


*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

{

	Synth(\mySynth,[\freq,rrand(300,600)]);
	0.5.wait;
	Synth(\mySynth,[\freq,rrand(300,600)]);
	0.5.wait;
	Synth(\mySynth,[\freq,rrand(300,600)]);
	0.5.wait;
	Synth(\mySynth,[\freq,rrand(300,600)]);
	0.5.wait;

}.fork;

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

(
a ={
	10.do
	{
	Synth(\mySynth,[\freq,rrand(300,600)]);
	0.5.wait;
	}


}.fork;
)
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

~myArray = [10,20,30,40,50,60,70];
~mArray[1];

a ={
	10.do{|i|
		~myArray[i].postln;
	0.5.wait;
	}
}.fork;


*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

~freq = [200,300,400,500,600];
(
a ={
	10.do{|i|
		Synth(\mySynth,[\freq, i + 1 * 200]);
	0.5.wait;
	}
}.fork;
)


a ={
	10.do{|i|
		Synth(\mySynth,[\freq, ~freq[i]]);
	0.5.wait;
	}
}.fork;


a ={
	~freq.size.do{|i|
		Synth(\mySynth,[\freq, ~freq[i]]);
	0.5.wait;
	}
}.fork;


a ={
	10.do{|i|
		Synth(\mySynth,[\freq, ~freq[i % ~freq.size]]);
	0.5.wait;
	}
}.fork;


*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

~freq = [200,300,400,500,600];
~dur = [0.25,0.25,0.25,0.5,0.5,0.25,1];


a ={
	inf.do{|i|
		Synth(\mySynth,[\freq, ~freq[i % ~freq.size]]);
		~dur[i % ~dur.size].wait;
	}
}.fork;


*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

(0.25!5);
(0..10);
(1..9) * 200;
(0.25!4) ++ [0.5,1,0.25] ++ (0.5!3);

Array.rand(10,300,500);
Array.series(10,500,50);
Array.interpolation(100,0,1);

[1,2,3,4,5].mirror;
[1,2,3,4,5].scramble;
[1,2,3,4,5].reverse;
[1000,23,1405,111].normalize;

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/


In many cases you'd prefer to work relative to some tempo, for instance, if you want to schedule events in terms of beats and measures.

SuperCollider measures tempi in beats per second (bps) rather than beats per minute, i.e

1 bps = 60 bpm
1.6666667 bps = 100 bpm
2 bps = 120 bpm
2.4 bps = 144 bpm
3 bps = 180 bpm

bps * 60 = bpm -> 2 * 60 = 120bpm
bpm / 60 = bps -> 120 bpm / 60 = 2


1.wait = Quarter Note
0.5.wait = Eighth Note
0.25.wait = Sixteenth Note



midi notes
60 = C3
61 = C#
62 = D
63 = D#
60.midicps coverts a midi number to a cycles per second value which the UGen will understand
440.cps converts a freq to midi value

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/


t = TempoClock(1);

(
a = {

	inf.do{
		Synth(\soundA,[\freq,rrand(300,500)]);
		0.5.wait;
	   //t.tempo = rrand(1,5);
	}

}.fork(t);
)



t.tempo = 2;
a.stop;
a.reset;
a.play;



*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
*/

~freq = (60..72);
~dur = (0.25!4) ++ [0.5,1] ++ (0.125!8);

t = TempoClock(1);

(
a = {

	inf.do{|i|
		Synth(\soundA,[\freq,~freq[i % ~freq.size].midicps]);
		~dur[i % ~dur.size].wait;
	   //t.tempo = rrand(1,5);
	}

}.fork(t);
)


t.tempo = 2;
a.stop;
a.reset;
a.play;